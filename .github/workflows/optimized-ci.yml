name: Optimized CI Pipeline

# Trigger on push to main/develop, pull requests, and manual dispatch
on:
  push:
    branches:
      - main
      - develop
  pull_request:
  workflow_dispatch:

jobs:
  # Job 1: Determine environment and detect docs-only changes
  setup:
    name: Setup and Environment Detection
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      docs_only: ${{ steps.check-docs.outputs.docs_only }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Determine environment based on branch name
      - name: Determine environment
        id: set-env
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          if [ "$BRANCH" = "main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          elif [ "$BRANCH" = "develop" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi
          echo "Detected environment: $(cat $GITHUB_OUTPUT | grep environment | cut -d'=' -f2)"

      # Check if only documentation files changed
      - name: Check for docs-only changes
        id: check-docs
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="HEAD~1"
          fi
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only $BASE_SHA HEAD)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "docs_only=false" >> $GITHUB_OUTPUT
            echo "No changed files detected"
            exit 0
          fi
          
          # Check if all changed files are markdown files
          DOCS_ONLY=true
          for file in $CHANGED_FILES; do
            if [[ ! "$file" =~ \.md$ ]]; then
              DOCS_ONLY=false
              break
            fi
          done
          
          echo "docs_only=$DOCS_ONLY" >> $GITHUB_OUTPUT
          echo "Documentation-only changes: $DOCS_ONLY"

  # Job 2: Quality checks using matrix strategy for parallel execution
  quality:
    name: Quality Checks
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.docs_only == 'false'
    strategy:
      matrix:
        check: [lint, test]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Node.js with caching
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Run the specific quality check from matrix
      - name: Run ${{ matrix.check }}
        run: npm run ${{ matrix.check }}

  # Job 3: Build the application
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [setup, quality]
    if: needs.setup.outputs.docs_only == 'false'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Node.js with caching
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      # Upload build artifacts
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
          retention-days: 7

  # Job 4: Deploy (only runs for production with code changes)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [setup, quality, build]
    # Only deploy if: environment is prod AND not docs-only AND previous jobs succeeded
    if: |
      needs.setup.outputs.environment == 'prod' &&
      needs.setup.outputs.docs_only == 'false' &&
      needs.build.result == 'success'
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Download build artifacts
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist/

      # Placeholder for actual deployment steps
      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."
          echo "Build artifacts ready in dist/"
          # Add your deployment commands here
          # Example: scp, rsync, cloud provider CLI, etc.
